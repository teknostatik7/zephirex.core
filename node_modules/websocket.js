window.ws_disable = 0;

const CoinbasePro = require('coinbase-pro');
const websocket = new CoinbasePro.WebsocketClient(window.marketPairs);
const transporter = require('transporter');
const decimalPlaces = require('decimalPlaces');
const authedClient = require('authedClient');
const sendEmail = require('sendEmail');
const getBalances = require('getBalances');


websocket.on('message', data => {
  /* work with data */
  if(data.type == "ticker"){
  	/// Ticker logic here
  	var pair = data.product_id;
		if(window.marketPairs[pair].lowestAsk == null){window.marketPairs[pair].lowestAsk = data.best_ask * (1-window.fee); window.marketPairs[pair].tempLowestAsk = data.best_ask * (1-window.fee)};
		if(window.marketPairs[pair].highestBid == null){window.marketPairs[pair].highestBid = data.best_bid / (1-window.fee); window.marketPairs[pair].tempHighestBid = data.best_bid / (1-window.fee)};

		if(data.best_ask < window.marketPairs[pair].tempLowestAsk){
			window.marketPairs[pair].tempLowestAsk = data.best_ask;

			//    *********** BUY LOGIC **********
			var basePortion = window.marketPairs[pair].calculate(window.marketPairs[pair].baseBalance, data.best_ask, window.marketPairs[pair].lowestAsk, decimalPlaces(window.marketPairs[pair].quote_increment));
			console.log(' - ' , pair, data.best_ask);
			if(basePortion >= window.marketPairs[pair].minBase && window.ws_disable == 0){
				window.ws_disable = 1;
				console.log("🔵 >>> Time to BUY " + pair + " @ " + data.best_ask);
				console.log("Max precision: ", decimalPlaces(window.marketPairs[pair].quote_increment));
				// Once trade is complete: Disable the disable and set low/high to data ask/bid.
				var buyParams = {
					type: 'market',
					side: 'buy',
				  funds: basePortion, // USD
				  product_id: pair,
				  time_in_force: 'IOC',
				};
	  		console.log(buyParams);
	  		authedClient.buy(buyParams)
	  			.then(async function (result){
	  				console.log(result);
	  				sendEmail(result, data.best_ask);
						var bal = await getBalances(authedClient);
						window.marketPairs[pair].lowestAsk = data.best_ask;
	  			})
	  			.catch(error => {
	  				console.log(error);
	  			})
	  		setTimeout(function(){window.ws_disable = 0}, window.delayMs);
			}
		}if(data.best_bid > window.marketPairs[pair].tempHighestBid){
			window.marketPairs[pair].tempHighestBid = data.best_bid;

			//    *********** SELL LOGIC **********
	  	var quotePortion = window.marketPairs[pair].calculate(window.marketPairs[pair].quoteBalance, data.best_bid, window.marketPairs[pair].highestBid, decimalPlaces(window.marketPairs[pair].base_increment));
			console.log(' + ' , pair, data.best_bid);
	  	if(quotePortion >= window.marketPairs[pair].minQuote && window.ws_disable == 0){
				window.ws_disable = 1;
				console.log("🔴 >>> Time to SELL " + pair + " @ " + data.best_bid);
				console.log("Max precision: ", decimalPlaces(window.marketPairs[pair].base_increment));
				// Once trade is complete: Disable the disable and set low/high to data ask/bid.
				var sellParams = {
					type: 'market',
					side: 'sell',
				  size: quotePortion, // BTC
				  product_id: pair,
				  time_in_force: 'IOC',
				};
				console.log(sellParams);
				authedClient.sell(sellParams)
					.then(async function (result){
						console.log(result);
	  				sendEmail(result, data.best_bid);
						var bal = await getBalances(authedClient);
						window.marketPairs[pair].highestBid = data.best_bid;
					})
					.catch(error => {
						console.log(error);
					})
	  		setTimeout(function(){window.ws_disable = 0}, window.delayMs);
			}
		}
  }
  else if(data.type == "status"){
		for (var pair in window.marketPairs){
			for (var x = 0; x < data.products.length; x++){
				if (data.products[x].id == pair){
					/*console.log("** BASE INCREMENT ** : ", pair, data.products[x].base_increment);
					console.log("** QUOTE INCREMENT ** : ", pair, data.products[x].quote_increment);*/
					window.marketPairs[pair].minQuote = Number(data.products[x].base_min_size);
					window.marketPairs[pair].minBase = Number(data.products[x].min_market_funds);
					window.marketPairs[pair].base_increment = Number(data.products[x].base_increment);
					window.marketPairs[pair].quote_increment = Number(data.products[x].quote_increment);
				}
			}
		}
  /*}else if(data.type == "heartbeat"){
  	console.log("❤: " + data.time);*/
  }
});
websocket.on('error', err => {
  /* handle error */
});
websocket.on('open', () => {
  console.log(" +++ Websocket Open +++ ");
	websocket.subscribe({ product_ids: window.pairs, channels: ['ticker', 'user', 'status'] });
	var mailOptions = {
	  from: window.config.senderEmail,
	  to: window.config.recipientEmail,
	  text: 'Websocket open! \r\n' + window.balanceSheet,
	};

	transporter.sendMail(mailOptions, function(error, info){
	  if (error) {
	    console.log(error);
	  } else {
	    console.log('Email sent: ' + info.response);
	  }
	});
});
websocket.on('close', () => {
  console.log("*** Websocket Has Closed ***");
	websocket.subscribe({ product_ids: window.pairs, channels: ['ticker', 'user', 'status'] });
});

module.exports = websocket;
